From e4e9d4cdfc3b5e27a3ad3f05810a96447ccf1f56 Mon Sep 17 00:00:00 2001
From: StanleyYP Wang <StanleyYP.Wang@mediatek.com>
Date: Wed, 5 Jul 2023 09:49:02 +0800
Subject: [PATCH 29/61] mtk: cfg80211: add support for updating background
 channel

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>
---
 include/net/cfg80211.h       | 14 ++++++++++++++
 include/uapi/linux/nl80211.h |  6 ++++++
 net/wireless/mlme.c          | 12 ++++++++++++
 3 files changed, 32 insertions(+)

--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -8769,6 +8769,20 @@ void cfg80211_sta_update_dfs_state(struc
 				   bool associated);
 
 /**
+ * cfg80211_background_radar_update_channel - notify background chandef has been updated
+ * @wiphy: the wiphy
+ * @chandef: the updated chandef
+ * @expand: whether or not the operating channel should expand its width
+ * after offchan CAC
+ *
+ * Update the background chandef based on driver's decision, and notify the userspace
+ * that the current channel of background chain should be updated.
+ */
+void cfg80211_background_radar_update_channel(struct wiphy *wiphy,
+					      const struct cfg80211_chan_def *chandef,
+					      bool expand);
+
+/**
  * cfg80211_background_cac_abort - Channel Availability Check offchan abort event
  * @wiphy: the wiphy
  *
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@ -6843,6 +6843,10 @@ enum nl80211_smps_mode {
  *	applicable for ETSI dfs domain where pre-CAC is valid for ever.
  * @NL80211_RADAR_CAC_STARTED: Channel Availability Check has been started,
  *	should be generated by HW if NL80211_EXT_FEATURE_DFS_OFFLOAD is enabled.
+ * @NL80211_RADAR_BACKGROUND_CHAN_UPDATE: background channel is updated by the
+ *	driver.
+ * @NL80211_RADAR_BACKGROUND_CHAN_EXPAND: background channel is updated by the
+ *	driver and required to expand main operating channel.
  * @NL80211_RADAR_STA_CAC_SKIPPED: STA set the DFS state to available
  *	when receiving CSA/assoc resp
  * @NL80211_RADAR_STA_CAC_EXPIRED: STA set the DFS state to usable
@@ -6855,6 +6859,8 @@ enum nl80211_radar_event {
 	NL80211_RADAR_NOP_FINISHED,
 	NL80211_RADAR_PRE_CAC_EXPIRED,
 	NL80211_RADAR_CAC_STARTED,
+	NL80211_RADAR_BACKGROUND_CHAN_UPDATE,
+	NL80211_RADAR_BACKGROUND_CHAN_EXPAND,
 	NL80211_RADAR_STA_CAC_SKIPPED,
 	NL80211_RADAR_STA_CAC_EXPIRED,
 };
--- a/net/wireless/mlme.c
+++ b/net/wireless/mlme.c
@@ -1281,6 +1281,18 @@ cfg80211_start_background_radar_detectio
 	return 0;
 }
 
+void cfg80211_background_radar_update_channel(struct wiphy *wiphy,
+					      const struct cfg80211_chan_def *chandef,
+					      bool expand)
+{
+	enum nl80211_radar_event event;
+
+	event = expand ? NL80211_RADAR_BACKGROUND_CHAN_EXPAND :
+			 NL80211_RADAR_BACKGROUND_CHAN_UPDATE;
+	nl80211_radar_notify(wiphy_to_rdev(wiphy), chandef, event, NULL, GFP_ATOMIC);
+}
+EXPORT_SYMBOL(cfg80211_background_radar_update_channel);
+
 void cfg80211_stop_background_radar_detection(struct wireless_dev *wdev)
 {
 	struct wiphy *wiphy = wdev->wiphy;
