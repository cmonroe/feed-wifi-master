From 103b24de6741cb11d088e6e2be478c7839d32ec4 Mon Sep 17 00:00:00 2001
From: StanleyYP Wang <StanleyYP.Wang@mediatek.com>
Date: Mon, 20 Feb 2023 14:25:24 +0800
Subject: [PATCH 19/61] mtk: mac80211: add sta-assisted DFS state update
 mechanism

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>
---
 include/net/cfg80211.h       | 14 +++++++++
 include/uapi/linux/nl80211.h |  6 ++++
 net/mac80211/mlme.c          | 14 +++++++++
 net/wireless/chan.c          | 61 ++++++++++++++++++++++++++++++++++++
 4 files changed, 95 insertions(+)

--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -8759,6 +8759,20 @@ void cfg80211_cac_event(struct net_devic
 			unsigned int link_id);
 
 /**
+ * cfg80211_sta_update_dfs_state - Update channel's DFS state during STA channel switch,
+ *				   association, and disassociation
+ * @wdev: the wireless device
+ * @bss_chandef: the current BSS channel definition
+ * @csa_chandef: the CSA channel definition
+ * @associated: whether STA is during association or disassociation process
+ *
+ */
+void cfg80211_sta_update_dfs_state(struct wireless_dev *wdev,
+				   const struct cfg80211_chan_def *bss_chandef,
+				   const struct cfg80211_chan_def *csa_chandef,
+				   bool associated);
+
+/**
  * cfg80211_background_cac_abort - Channel Availability Check offchan abort event
  * @wiphy: the wiphy
  *
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@ -6843,6 +6843,10 @@ enum nl80211_smps_mode {
  *	applicable for ETSI dfs domain where pre-CAC is valid for ever.
  * @NL80211_RADAR_CAC_STARTED: Channel Availability Check has been started,
  *	should be generated by HW if NL80211_EXT_FEATURE_DFS_OFFLOAD is enabled.
+ * @NL80211_RADAR_STA_CAC_SKIPPED: STA set the DFS state to available
+ *	when receiving CSA/assoc resp
+ * @NL80211_RADAR_STA_CAC_EXPIRED: STA set the DFS state to usable
+ *	when STA is disconnected or leaving the channel
  */
 enum nl80211_radar_event {
 	NL80211_RADAR_DETECTED,
@@ -6851,6 +6855,8 @@ enum nl80211_radar_event {
 	NL80211_RADAR_NOP_FINISHED,
 	NL80211_RADAR_PRE_CAC_EXPIRED,
 	NL80211_RADAR_CAC_STARTED,
+	NL80211_RADAR_STA_CAC_SKIPPED,
+	NL80211_RADAR_STA_CAC_EXPIRED,
 };
 
 /**
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -2599,6 +2599,11 @@ ieee80211_sta_process_chanswitch(struct
 	if (csa_ie.mode)
 		ieee80211_vif_block_queues_csa(sdata);
 
+	cfg80211_sta_update_dfs_state(&sdata->wdev,
+				      &link->conf->chanreq.oper,
+				      &csa_ie.chanreq.oper,
+				      sdata->vif.cfg.assoc);
+
 	cfg80211_ch_switch_started_notify(sdata->dev, &csa_ie.chanreq.oper,
 					  link->link_id, csa_ie.count,
 					  csa_ie.mode);
@@ -3665,6 +3670,10 @@ static void ieee80211_set_disassoc(struc
 		link = sdata_dereference(sdata->link[link_id], sdata);
 		if (!link)
 			continue;
+
+		cfg80211_sta_update_dfs_state(&sdata->wdev,
+					      &link->conf->chanreq.oper,
+					      NULL, sdata->vif.cfg.assoc);
 		ieee80211_link_release_channel(link);
 	}
 
@@ -5935,6 +5944,11 @@ static void ieee80211_rx_mgmt_assoc_resp
 		for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
 			if (link->tx_conf[ac].uapsd)
 				resp.uapsd_queues |= ieee80211_ac_to_qos_mask[ac];
+
+		if (status_code == WLAN_STATUS_SUCCESS)
+			cfg80211_sta_update_dfs_state(&sdata->wdev,
+						      &link->conf->chanreq.oper,
+						      NULL, sdata->vif.cfg.assoc);
 	}
 
 	if (ieee80211_vif_is_mld(&sdata->vif)) {
--- a/net/wireless/chan.c
+++ b/net/wireless/chan.c
@@ -14,6 +14,7 @@
 #include <net/cfg80211.h>
 #include "core.h"
 #include "rdev-ops.h"
+#include "nl80211.h"
 
 static bool cfg80211_valid_60g_freq(u32 freq)
 {
@@ -1721,6 +1722,66 @@ bool cfg80211_any_usable_channels(struct
 }
 EXPORT_SYMBOL(cfg80211_any_usable_channels);
 
+static void cfg80211_sta_radar_notify(struct wiphy *wiphy,
+				      const struct cfg80211_chan_def *chandef,
+				      enum nl80211_radar_event event)
+{
+	struct wireless_dev *wdev;
+
+	list_for_each_entry(wdev, &wiphy->wdev_list, list) {
+		if (cfg80211_chandef_dfs_required(wiphy, chandef, wdev->iftype) > 0) {
+			nl80211_radar_notify(wiphy_to_rdev(wiphy), chandef,
+					     event, wdev->netdev, GFP_KERNEL);
+			return;
+		}
+	}
+}
+
+void cfg80211_sta_update_dfs_state(struct wireless_dev *wdev,
+				   const struct cfg80211_chan_def *bss_chandef,
+				   const struct cfg80211_chan_def *csa_chandef,
+				   bool associated)
+{
+	bool csa_active = !!csa_chandef;
+	enum nl80211_dfs_state dfs_state = NL80211_DFS_USABLE;
+	enum nl80211_radar_event event = NL80211_RADAR_STA_CAC_EXPIRED;
+
+	if (!bss_chandef || !bss_chandef->chan ||
+	    bss_chandef->chan->band != NL80211_BAND_5GHZ)
+		return;
+
+	/* assume csa channel is cac completed */
+	if (csa_active &&
+	    (cfg80211_chandef_dfs_usable(wdev->wiphy, csa_chandef) ||
+	    cfg80211_chandef_dfs_available(wdev->wiphy, csa_chandef))) {
+		cfg80211_set_dfs_state(wdev->wiphy, csa_chandef, NL80211_DFS_AVAILABLE);
+		cfg80211_sta_radar_notify(wdev->wiphy, csa_chandef,
+					  NL80211_RADAR_STA_CAC_SKIPPED);
+		netdev_info(wdev->netdev, "Set CSA channel's DFS state to available\n");
+	}
+
+	/* avoid updating the dfs state during nop */
+	if (!cfg80211_chandef_dfs_usable(wdev->wiphy, bss_chandef) &&
+	    !cfg80211_chandef_dfs_available(wdev->wiphy, bss_chandef))
+		return;
+
+	if (associated && !csa_active) {
+		dfs_state = NL80211_DFS_AVAILABLE;
+		event = NL80211_RADAR_STA_CAC_SKIPPED;
+	}
+
+	cfg80211_set_dfs_state(wdev->wiphy, bss_chandef, dfs_state);
+	cfg80211_sta_radar_notify(wdev->wiphy, bss_chandef, event);
+
+	if (csa_active)
+		netdev_info(wdev->netdev, "Set origin channel's DFS state to usable\n");
+	else
+		netdev_info(wdev->netdev, "Set BSS channel's DFS state to %s due to %s\n",
+			    (dfs_state == NL80211_DFS_USABLE) ? "usable" : "available",
+			    associated ? "association" : "disassociation");
+}
+EXPORT_SYMBOL(cfg80211_sta_update_dfs_state);
+
 struct cfg80211_chan_def *wdev_chandef(struct wireless_dev *wdev,
 				       unsigned int link_id)
 {
