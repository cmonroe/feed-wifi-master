From d9ec9b87f64abcfec2a8ae78648a30f4c120842d Mon Sep 17 00:00:00 2001
From: Bo Jiao <Bo.Jiao@mediatek.com>
Date: Tue, 6 Feb 2024 14:46:59 +0800
Subject: [PATCH 2/2] wifi: mt76: mt7915: add SER overlap handle

CR-ID: WCNCR00355921
Signed-off-by: Bo Jiao <Bo.Jiao@mediatek.com>
---
 dma.c        |  3 ++-
 mcu.c        |  7 +++++--
 mt76.h       |  9 +++++++++
 mt7915/mac.c | 11 +++++++++++
 mt7915/mcu.c |  7 +++++++
 5 files changed, 34 insertions(+), 3 deletions(-)

--- a/dma.c
+++ b/dma.c
@@ -506,7 +506,8 @@ mt76_dma_tx_queue_skb_raw(struct mt76_de
 	dma_addr_t addr;
 	int ret = -ENOMEM;
 
-	if (test_bit(MT76_MCU_RESET, &dev->phy.state)) {
+	if (test_bit(MT76_MCU_RESET, &dev->phy.state) ||
+	    dev->recovery_state == MT76_RECOVERY_TRIGGERED) {
 		ret = -EAGAIN;
 		goto error;
 	}
--- a/mcu.c
+++ b/mcu.c
@@ -41,7 +41,9 @@ struct sk_buff *mt76_mcu_get_response(st
 	timeout = expires - jiffies;
 	wait_event_timeout(dev->mcu.wait,
 			   (!skb_queue_empty(&dev->mcu.res_q) ||
-			    test_bit(MT76_MCU_RESET, &dev->phy.state)),
+			    test_bit(MT76_MCU_RESET, &dev->phy.state) ||
+			    dev->recovery_state == MT76_RECOVERY_TRIGGERED ||
+			    dev->recovery_state == MT76_RECOVERY_OVERLAP_TRIGGERED),
 			   timeout);
 	return skb_dequeue(&dev->mcu.res_q);
 }
@@ -91,7 +93,8 @@ int mt76_mcu_skb_send_and_get_msg(struct
 			goto out;
 
 		if (retry && retry_cnt < MT76_MSG_MAX_RETRY_CNT) {
-			if (test_bit(MT76_MCU_RESET, &dev->phy.state))
+			if (test_bit(MT76_MCU_RESET, &dev->phy.state) ||
+			    dev->recovery_state == MT76_RECOVERY_TRIGGERED)
 				usleep_range(200000, 500000);
 			dev_err(dev->dev, "send message %08x timeout, try again(%d).\n",
 				cmd, (MT76_MSG_MAX_RETRY_CNT - retry_cnt));
--- a/mt76.h
+++ b/mt76.h
@@ -477,6 +477,14 @@ enum {
 	MT76_STATE_WED_RESET,
 };
 
+enum {
+	MT76_RECOVERY_INIT,
+	MT76_RECOVERY_TRIGGERED,
+	MT76_RECOVERY_OVERLAP_TRIGGERED,
+	MT76_RECOVERY_PROCESS,
+	MT76_RECOVERY_DONE = MT76_RECOVERY_INIT,
+};
+
 struct mt76_hw_cap {
 	bool has_2ghz;
 	bool has_5ghz;
@@ -896,6 +904,7 @@ struct mt76_dev {
 	wait_queue_head_t tx_wait;
 	/* spinclock used to protect wcid pktid linked list */
 	spinlock_t status_lock;
+	u16 recovery_state;
 
 	u32 wcid_mask[DIV_ROUND_UP(MT76_N_WCIDS, 32)];
 	u32 wcid_phy_mask[DIV_ROUND_UP(MT76_N_WCIDS, 32)];
--- a/mt7915/mac.c
+++ b/mt7915/mac.c
@@ -1555,6 +1555,7 @@ void mt7915_mac_reset_work(struct work_s
 	if (!(READ_ONCE(dev->recovery.state) & MT_MCU_CMD_STOP_DMA))
 		return;
 
+	dev->mt76.recovery_state = MT76_RECOVERY_PROCESS;
 	dev_info(dev->mt76.dev,"\n%s L1 SER recovery start.",
 		 wiphy_name(dev->mt76.hw->wiphy));
 
@@ -1621,6 +1622,7 @@ void mt7915_mac_reset_work(struct work_s
 
 	mt7915_update_beacons(dev);
 
+	dev->mt76.recovery_state = MT76_RECOVERY_DONE;
 	dev_info(dev->mt76.dev,"\n%s L1 SER recovery completed.",
 		 wiphy_name(dev->mt76.hw->wiphy));
 }
@@ -1759,6 +1761,15 @@ void mt7915_reset(struct mt7915_dev *dev
 		return;
 	}
 
+	if ((READ_ONCE(dev->recovery.state) & MT_MCU_CMD_STOP_DMA)) {
+		if (dev->mt76.recovery_state != MT76_RECOVERY_DONE)
+			dev->mt76.recovery_state = MT76_RECOVERY_OVERLAP_TRIGGERED;
+		else
+			dev->mt76.recovery_state = MT76_RECOVERY_TRIGGERED;
+
+		wake_up(&dev->mt76.mcu.wait);
+	}
+
 	queue_work(dev->mt76.wq, &dev->reset_work);
 	wake_up(&dev->reset_wait);
 }
--- a/mt7915/mcu.c
+++ b/mt7915/mcu.c
@@ -223,6 +223,13 @@ mt7915_mcu_send_message(struct mt76_dev
 	enum mt76_mcuq_id qid;
 	int ret;
 
+	if (mdev->recovery_state == MT76_RECOVERY_OVERLAP_TRIGGERED) {
+		dev_info(dev->mt76.dev,"\n%s L1 SER recovery overlap, drop message %08x.",
+			 wiphy_name(dev->mt76.hw->wiphy), cmd);
+		dev_kfree_skb(skb);
+		return -EPERM;
+	}
+
 	ret = mt76_connac2_mcu_fill_message(mdev, skb, cmd, wait_seq);
 	if (ret)
 		return ret;
