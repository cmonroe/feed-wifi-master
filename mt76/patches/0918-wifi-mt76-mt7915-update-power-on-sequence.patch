From b8076a11b6051ed0fe1deb6c94e97bf80a13fbff Mon Sep 17 00:00:00 2001
From: Peter Chiu <chui-hao.chiu@mediatek.com>
Date: Thu, 14 Mar 2024 17:55:12 +0800
Subject: [PATCH] wifi: mt76: mt7915: update power on sequence

Update power on sequence to prevent unexpected behavior.

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

--- a/mt7915/mt7915.h
+++ b/mt7915/mt7915.h
@@ -327,6 +327,8 @@ struct mt7915_dev {
 	struct reset_control *rstc;
 	void __iomem *dcm;
 	void __iomem *sku;
+
+	u32 adie_type;
 };
 
 enum {
--- a/mt7915/regs.h
+++ b/mt7915/regs.h
@@ -775,6 +775,7 @@ enum offs_rev {
 #define MT_TOP_RGU_SYSRAM_PDN		(MT_TOP_RGU_BASE + 0x050)
 #define MT_TOP_RGU_SYSRAM_SLP		(MT_TOP_RGU_BASE + 0x054)
 #define MT_TOP_WFSYS_PWR		(MT_TOP_RGU_BASE + 0x010)
+#define MT_TOP_BGFYS_PWR		(MT_TOP_RGU_BASE + 0x020)
 #define MT_TOP_PWR_EN_MASK		BIT(7)
 #define MT_TOP_PWR_ACK_MASK		BIT(6)
 #define MT_TOP_PWR_KEY_MASK		GENMASK(31, 16)
@@ -886,6 +887,7 @@ enum offs_rev {
 #define MT_ADIE_SLP_CTRL(_band, ofs)	(MT_ADIE_SLP_CTRL_BASE(_band) + (ofs))
 
 #define MT_ADIE_SLP_CTRL_CK0(_band)	MT_ADIE_SLP_CTRL(_band, 0x120)
+#define MT_ADIE_SLP_CTRL_CK1(_band)	MT_ADIE_SLP_CTRL(_band, 0x124)
 
 /* ADIE */
 #define MT_ADIE_CHIP_ID			0x02c
--- a/mt7915/soc.c
+++ b/mt7915/soc.c
@@ -261,6 +261,7 @@ static int mt7986_wmac_consys_lockup(str
 		      MT_INFRACFG_TX_EN_MASK,
 		      FIELD_PREP(MT_INFRACFG_TX_EN_MASK, enable));
 
+	usleep_range(1000, 2000);
 	return 0;
 }
 
@@ -845,6 +846,10 @@ static void mt7986_wmac_subsys_setting(s
 		 MT_CONN_INFRA_OSC_STB_TIME_MASK, 0x80706);
 
 	/* prevent subsys from power on/of in a short time interval */
+	mt76_rmw(dev, MT_TOP_BGFYS_PWR,
+		 MT_TOP_PWR_ACK_MASK | MT_TOP_PWR_KEY_MASK,
+		 (0x42540000));
+
 	mt76_rmw(dev, MT_TOP_WFSYS_PWR,
 		 MT_TOP_PWR_ACK_MASK | MT_TOP_PWR_KEY_MASK,
 		 MT_TOP_PWR_KEY);
@@ -915,7 +920,7 @@ static void mt7986_wmac_clock_enable(str
 
 		read_poll_timeout(mt76_rr, cur, !(cur & MT_SLP_CTRL_BSY_MASK),
 				  USEC_PER_MSEC, 50 * USEC_PER_MSEC, false,
-				  dev, MT_ADIE_SLP_CTRL_CK0(0));
+				  dev, MT_ADIE_SLP_CTRL_CK0(1));
 	}
 	mt76_wmac_spi_unlock(dev);
 
@@ -1155,12 +1160,14 @@ int mt7986_wmac_enable(struct mt7915_dev
 	if (ret)
 		return ret;
 
+	dev->adie_type = adie_type;
+
 	return mt7986_wmac_sku_update(dev, adie_type);
 }
 
 void mt7986_wmac_disable(struct mt7915_dev *dev)
 {
-	u32 cur;
+	u32 cur, i;
 
 	mt7986_wmac_top_wfsys_wakeup(dev, true);
 
@@ -1179,6 +1186,20 @@ void mt7986_wmac_disable(struct mt7915_d
 	mt76_rmw_field(dev, MT_AFE_DIG_EN_02(0), MT_AFE_MCU_BPLL_CFG_MASK, 0x2);
 	mt76_rmw_field(dev, MT_AFE_DIG_EN_02(0), MT_AFE_WPLL_CFG_MASK, 0x2);
 
+	/* Disable adie top clock */
+	mt76_wmac_spi_lock(dev);
+	for (i = 0; i < 2; i++) {
+		if (is_7975(dev, i, dev->adie_type) || is_7976(dev, i, dev->adie_type)) {
+			mt76_rmw_field(dev, MT_ADIE_SLP_CTRL_CK1(i),
+				       MT_SLP_CTRL_EN_MASK, 0x0);
+
+			read_poll_timeout(mt76_rr, cur, !(cur & MT_SLP_CTRL_BSY_MASK),
+					  USEC_PER_MSEC, 50 * USEC_PER_MSEC,
+					  false, dev, MT_ADIE_SLP_CTRL_CK1(i));
+		}
+	}
+	mt76_wmac_spi_unlock(dev);
+
 	/* Reset EMI */
 	mt76_rmw_field(dev, MT_CONN_INFRA_EMI_REQ,
 		       MT_CONN_INFRA_EMI_REQ_MASK, 0x1);
@@ -1190,6 +1211,28 @@ void mt7986_wmac_disable(struct mt7915_d
 		       MT_CONN_INFRA_INFRA_REQ_MASK, 0x0);
 
 	mt7986_wmac_top_wfsys_wakeup(dev, false);
+
+	mt76_rmw(dev, MT_TOP_CONN_INFRA_WAKEUP,
+		 MT_TOP_CONN_INFRA_WAKEUP_MASK, 0x1);
+
+	usleep_range(1000, 1100);
+
+	mt76_wmac_spi_lock(dev);
+	for (i = 0; i < 2; i++) {
+		if (is_7975(dev, i, dev->adie_type) || is_7976(dev, i, dev->adie_type)) {
+			mt76_rmw_field(dev, MT_ADIE_SLP_CTRL_CK0(i),
+				       MT_SLP_CTRL_EN_MASK, 0x0);
+
+			read_poll_timeout(mt76_rr, cur, !(cur & MT_SLP_CTRL_BSY_MASK),
+					  USEC_PER_MSEC, 50 * USEC_PER_MSEC,
+					  false, dev, MT_ADIE_SLP_CTRL_CK0(i));
+		}
+	}
+	mt76_wmac_spi_unlock(dev);
+
+	mt76_rmw(dev, MT_TOP_CONN_INFRA_WAKEUP,
+		 MT_TOP_CONN_INFRA_WAKEUP_MASK, 0x0);
+
 	mt7986_wmac_consys_lockup(dev, true);
 	mt7986_wmac_consys_reset(dev, false);
 }
